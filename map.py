from parameters import *
from numba.core import types
from numba.typed import Dict
from numba import int32
import pygame

# тут создается карта и всё связанное с ней
_ = False
# map_y это карта нашей игры, которая состоил из трех комнат
map_y = [
    [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, _, _, _, _, _, 2, _, _, 2, 2, _, _, 1, 1, 1, _, _, _, _, _, 1, 1],
        [1, 2, 2, 2, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, 4, _, _, 1],
        [1, _, _, _, _, _, _, _, _, _, _, 2, 2, _, _, _, _, _, _, _, _, _, 1],
        [1, _, 2, 2, _, _, _, _, _, _, _, _, 2, _, _, _, _, 4, _, _, 4, _, 1],
        [1, _, 3, _, _, _, 4, _, _, 2, _, _, 2, 2, 2, 2, _, _, 4, _, _, _, 1],
        [1, _, 3, _, _, _, 2, _, _, 2, 2, _, 2, _, _, _, _, _, _, _, 4, _, 1],
        [1, _, _, 3, _, _, 2, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _],
        [1, _, 3, _, _, _, _, _, _, _, 3, _, _, 4, 4, _, _, 3, 3, 3, _, _, 1],
        [1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1],
        [1, _, _, _, _, _, 3, _, 2, 2, _, _, _, _, 2, _, _, _, _, _, 2, 2, 1],
        [1, _, _, _, _, _, 3, _, _, _, _, _, _, _, 2, 2, 2, _, _, _, 2, _, 1],
        [1, _, _, _, _, 3, 3, 3, 3, _, _, _, _, 2, 2, _, _, _, _, _, _, _, 1],
        [1, _, 3, _, _, _, _, _, _, _, 3, _, _, _, _, _, _, _, 3, 3, _, _, 1],
        [1, _, _, _, _, _, _, 1, _, _, 4, _, _, _, _, _, _, _, _, 2, _, _, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    [
        [2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
        [5, _, _, _, _, _, 6, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 5],
        [5, 6, 6, _, _, _, _, _, _, 6, 6, 6, _, _, 5, _, 6, 6, 6, 6, 6, _, 5],
        [5, _, _, _, _, _, _, _, _, _, _, 6, 6, _, 5, _, _, _, _, _, 6, _, 5],
        [5, _, _, 6, _, _, _, _, _, _, _, _, 6, _, _, _, _, _, 6, _, 6, _, 5],
        [5, _, 7, _, _, _, 6, _, _, 6, 6, _, 6, _, _, _, _, _, _, _, 6, _, 5],
        [5, _, _, 7, _, _, 6, _, _, _, 8, _, _, _, _, _, _, _, _, _, _, _, 5],
        [_, _, 7, _, _, _, 6, 6, _, _, 6, _, _, _, _, _, _, 7, 7, 7, _, _, _],
        [5, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 5],
        [5, _, _, _, _, _, _, _, _, 7, 7, 7, _, _, 7, 7, 7, _, _, _, 6, _, 5],
        [5, _, _, 5, 5, _, 7, 7, 7, 7, _, _, _, _, _, _, _, _, _, _, 6, _, 5],
        [5, _, _, _, _, _, _, _, _, 7, _, _, _, _, _, 5, 5, 5, _, _, 6, _, 5],
        [5, 6, 5, _, _, _, _, 5, _, _, _, _, _, _, _, 5, _, _, _, 6, 6, _, 5],
        [5, _, 7, _, _, _, 7, _, _, 6, _, _, 6, _, 5, 5, _, _, 8, _, _, _, 5],
        [5, _, _, _, _, _, _, 5, _, _, 8, _, _, _, _, _, _, _, _, _, _, _, 5],
        [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
    ],
    [
        [3, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 11],
        [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
    ]
]

new_maps = map_y[0]  # создаем одну огромную карту
x = len(map_y)
for i in range(1, x):
    for j in range(len(new_maps)):
        new_maps[j] += map_y[i][j]

# ширина мира
W_WORLD = len(new_maps[0]) * CELL

# длина мира
H_WORLD = len(new_maps) * CELL

# множество во стенами
mini_map = set()
txt_map = Dict.empty(key_type=types.UniTuple(int32, 2), value_type=int32)
collision_walls = []

for j, row in enumerate(new_maps):  # добавляем текстуры стен в словарь
    for i, char in enumerate(row):
        # тк _ у является False, то мы может намного удобнее пробегаться по всей карте
        if char:
            # добавляем в множество координаты стен, умноженные на размер кваррата карты
            mini_map.add((i * MAP_CELL, j * MAP_CELL))
            collision_walls.append(pygame.Rect(i * CELL, j * CELL, CELL, CELL))
            if char == 1:  # проверяем элемент списка (номер текстуры стены)
                txt_map[(i * CELL, j * CELL)] = 1
            elif char == 2:
                txt_map[(i * CELL, j * CELL)] = 2
            elif char == 3:
                txt_map[(i * CELL, j * CELL)] = 3
            elif char == 4:
                txt_map[(i * CELL, j * CELL)] = 4
            elif char == 5:
                txt_map[(i * CELL, j * CELL)] = 5
            elif char == 6:
                txt_map[(i * CELL, j * CELL)] = 6
            elif char == 7:
                txt_map[(i * CELL, j * CELL)] = 7
            elif char == 8:
                txt_map[(i * CELL, j * CELL)] = 8
            elif char == 8:
                txt_map[(i * CELL, j * CELL)] = 8
            elif char == 9:
                txt_map[(i * CELL, j * CELL)] = 9
            elif char == 10:
                txt_map[(i * CELL, j * CELL)] = 10
            elif char == 11:
                txt_map[(i * CELL, j * CELL)] = 11
            elif char == 12:
                txt_map[(i * CELL, j * CELL)] = 12
            elif char == 13:
                txt_map[(i * CELL, j * CELL)] = 13
            elif char == 14:
                txt_map[(i * CELL, j * CELL)] = 14


class Camera:  # Класс для движения фокуса миникарты за игроком
    def __init__(self, monitor_map, gamer):
        self.gamer = gamer
        self.monitor_map = monitor_map
        self.dx = 0

    def update(self):
        # нам нужна только ось X
        self.dx = -(self.gamer.minirect.x + self.gamer.minirect.w // 2 - MAP_RES[0] // 10)

    def apply(self, x, y):
        # корректируем положение объекта на миникарте и рисуем его
        x += self.dx
        pygame.draw.rect(self.monitor_map, DARKORANGE, (x, y, MAP_CELL, MAP_CELL), 2)
